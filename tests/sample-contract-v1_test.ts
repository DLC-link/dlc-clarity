// deno-lint-ignore-file require-await no-explicit-any prefer-const
// @ts-ignore
import {
  Clarinet,
  Tx,
  Chain,
  Account,
  types,
  assertEquals,
  pricePackageToCV,
  assertStringIncludes,
  assertMatch,
  hex2ascii,
  shiftPriceValue,
  PricePackage,
  Block,
  // getIntValueFromPrintOutput,
  // getStringValueFromPrintOutput,
} from './deps.ts';

// Unfortunately it is not straightforward to import "../src/stacks-redstone.ts"
// in Clarinet test files. Values are therefore generated by the helper scripts
// found in the ./scripts directory. The parameters used to generate the data
// is provided in comments.

// TODO: Tests to write:
// - user tries to close without repaying borrowed amount
// - user can close if he hasnt borrowed
// - borrow without collateral/funded state fails
// - repay more then borrowed amount
// - repay fails with proper error message on negative balance

const BTChex = 'BTC';
// const UUID = UUID;
const nftAssetContract = 'open-dlc';
const dlcManagerContract = 'dlc-manager-v1';
const sampleProtocolContract = 'sample-contract-loan-v1';

const contractPrincipal = (deployer: Account, contract: string) => `${deployer.address}.${contract}`;

function registerAttestors(chain: Chain, deployer: Account) {
  let register_1 = chain.mineBlock([
    Tx.contractCall(dlcManagerContract, 'register-attestor', [types.ascii('1.2.3.4')], deployer.address),
  ]);
  let register_2 = chain.mineBlock([
    Tx.contractCall(dlcManagerContract, 'register-attestor', [types.ascii('5.6.7.8')], deployer.address),
  ]);
  let register_3 = chain.mineBlock([
    Tx.contractCall(dlcManagerContract, 'register-attestor', [types.ascii('9.10.11.12')], deployer.address),
  ]);

  return { register_1, register_2, register_3 };
}

function openLoan(
  chain: Chain,
  protocol_contract_user: Account,
  protocol_contract_deployer: Account,
  deployer: Account,
  callbackContract: string,
  loanParams: {
    vaultAmount: number;
    btcDeposit: number;
    liquidationRatio: number;
    liquidationFee: number;
  } = {
    vaultAmount: 1000000,
    btcDeposit: 1,
    liquidationRatio: 14000,
    liquidationFee: 1000,
  }
) {
  registerAttestors(chain, deployer);

  chain.mineBlock([
    Tx.contractCall(
      dlcManagerContract,
      'whitelist-contract',
      [types.principal(contractPrincipal(protocol_contract_deployer, sampleProtocolContract))],
      deployer.address
    ),
  ]);

  const block = chain.mineBlock([
    Tx.contractCall(
      callbackContract,
      'setup-loan',
      [
        types.uint(shiftPriceValue(loanParams.btcDeposit)),
        types.uint(loanParams.liquidationRatio),
        types.uint(loanParams.liquidationFee),
        types.uint(10),
      ],
      protocol_contract_user.address
    ),
  ]);

  block.receipts[0].result.expectOk();

  const setupLoanPrintEvent = block.receipts[0].events.find((event: any) => {
    return event.contract_event && event.contract_event.contract_identifier.includes('sample-contract-loan-v1');
  });

  assertEquals(typeof setupLoanPrintEvent, 'object');
  assertEquals(setupLoanPrintEvent.type, 'contract_event');
  assertEquals(setupLoanPrintEvent.contract_event.topic, 'print');
  assertStringIncludes(setupLoanPrintEvent.contract_event.value, 'loan-id: u1, status: "ready"');

  const createDLCPrintEvent = block.receipts[0].events.find((event: any) => {
    return event.contract_event && event.contract_event.contract_identifier.includes('dlc-manager-v1');
  });

  assertEquals(typeof createDLCPrintEvent, 'object');
  assertEquals(createDLCPrintEvent.type, 'contract_event');
  assertEquals(createDLCPrintEvent.contract_event.topic, 'print');
  let matchRegex = assertMatch(
    createDLCPrintEvent.contract_event.value,
    new RegExp(
      /^{attestors: \[{dns: "1.2.3.4"}, {dns: "9.10.11.12"}\], callback-contract: STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.sample-contract-loan-v1, creator: ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG, event-source: "dlclink:create-dlc:v1", protocol-wallet: ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP, uuid: 0x[a-fA-F0-9]{64}}$/
    )
  );

  const mintEvent = block.receipts[0].events.find((event: any) => {
    return event.nft_mint_event && event.nft_mint_event.asset_identifier.includes('open-dlc');
  });

  assertEquals(typeof mintEvent, 'object');
  assertEquals(mintEvent.type, 'nft_mint_event');
  assertEquals(mintEvent.nft_mint_event.asset_identifier.split('::')[1], nftAssetContract);
  assertEquals(mintEvent.nft_mint_event.recipient.split('.')[1], dlcManagerContract);

  const loanBlock = chain.mineBlock([
    Tx.contractCall(callbackContract, 'get-loan', [types.uint(1)], protocol_contract_user.address),
  ]);

  //The loan account in the sample protocl contact
  const loan: any = loanBlock.receipts[0].result.expectSome().expectTuple();

  assertMatch(loan.dlc_uuid, new RegExp(/^\(some 0x[a-fA-F0-9]{64}\)$/));
  assertEquals(loan.status, '"ready"');
  assertEquals(loan['vault-collateral'], 'u100000000');
  assertEquals(loan['vault-loan'], 'u0');

  const dlcUuid = loan.dlc_uuid.expectSome();
  return dlcUuid;
}

Clarinet.test({
  name: 'setup-loan on sample contract creates the loan, emits a dlclink event, and mints an nft',
  async fn(chain: Chain, accounts: Map<string, Account>) {
    const deployer = accounts.get('deployer')!;
    const protocol_contract_deployer = accounts.get('protocol_contract_deployer')!;
    const protocol_contract_user = accounts.get('protocol_contract_user')!;

    const UUID = openLoan(
      chain,
      protocol_contract_user,
      protocol_contract_deployer,
      deployer,
      contractPrincipal(protocol_contract_deployer, sampleProtocolContract)
    );

    let block = chain.mineBlock([Tx.contractCall(dlcManagerContract, 'get-dlc', [UUID], deployer.address)]);

    const dlc: any = block.receipts[0].result.expectSome().expectTuple();

    assertEquals(dlc.uuid, UUID);
    assertEquals(dlc.creator, protocol_contract_user.address);

    let block2 = chain.mineBlock([
      Tx.contractCall(
        contractPrincipal(protocol_contract_deployer, sampleProtocolContract),
        'get-loan',
        [types.uint(1)],
        protocol_contract_user.address
      ),
    ]);

    //The loan account in the sample protocl contact
    const loan: any = block2.receipts[0].result.expectSome().expectTuple();
    const dlcUuid = loan.dlc_uuid.expectSome();

    assertEquals(dlcUuid, UUID);
    assertEquals(loan.status, '"ready"');
    assertEquals(loan['vault-collateral'], 'u100000000');
    assertEquals(loan['vault-loan'], 'u0');
  },
});

Clarinet.test({
  name: 'get-loan-by-uuid works after creating the loan',
  async fn(chain: Chain, accounts: Map<string, Account>) {
    const deployer = accounts.get('deployer')!;
    const protocol_contract_deployer = accounts.get('protocol_contract_deployer')!;
    const protocol_contract_user = accounts.get('protocol_contract_user')!;

    const UUID = openLoan(
      chain,
      protocol_contract_user,
      protocol_contract_deployer,
      deployer,
      contractPrincipal(protocol_contract_deployer, sampleProtocolContract)
    );

    let block = chain.mineBlock([
      Tx.contractCall(
        contractPrincipal(protocol_contract_deployer, sampleProtocolContract),
        'get-loan-by-uuid',
        [UUID],
        protocol_contract_user.address
      ),
    ]);

    const account: any = block.receipts[0].result.expectOk();
    assertStringIncludes(
      account,
      `dlc_uuid: (some ${UUID}), liquidation-fee: u1000, liquidation-ratio: u14000, owner: ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG, status: "ready", vault-collateral: u100000000, vault-loan: u0`
    );
  },
});

// Clarinet.test({
//   name: "close-loan on sample protocol contract should close the loan, emit a dlclink event, and burn the nft",
//   async fn(chain: Chain, accounts: Map<string, Account>) {
//     const deployer = accounts.get('deployer')!;
//     const deployer_2 = accounts.get('deployer_2')!;

//     openLoan(chain, deployer, contractPrincipal(deployer_2, sampleProtocolContract));

//     let block = chain.mineBlock([
//       Tx.contractCall(contractPrincipal(deployer_2, sampleProtocolContract), "close-loan", [types.uint(1)], deployer_2.address)
//     ]);
//     assertStringIncludes(block.receipts[0].events[0].contract_event.value, 'status: "pre-repaid", uuid: 0x66616b6575756964');
//     assertStringIncludes(block.receipts[0].events[1].contract_event.value, 'callback-contract: STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.sample-contract-loan-v0-1, caller: STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.sample-contract-loan-v0-1, creator: STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.sample-contract-loan-v0-1, event-source: "dlclink:close-dlc:v0-1", outcome: u0, uuid: 0x66616b6575756964')

//     const block2 = chain.mineBlock([
//       Tx.contractCall(dlcManagerContract, "post-close-dlc", [types.buff(UUID), types.principal(contractPrincipal(deployer_2, sampleProtocolContract))], deployer.address)
//     ]);

//     assertStringIncludes(block2.receipts[0].events[0].contract_event.value, 'closing-price: none, event-source: "dlclink:close-dlc-internal:v0", uuid: 0x66616b6575756964')
//     const burnEvent = block2.receipts[0].events[2];
//     assertEquals(typeof burnEvent, 'object');
//     assertEquals(burnEvent.type, 'nft_burn_event');
//     assertEquals(burnEvent.nft_burn_event.asset_identifier.split("::")[1], nftAssetContract);
//     assertEquals(burnEvent.nft_burn_event.sender.split(".")[1], dlcManagerContract);
//     assertEquals(hex2ascii(burnEvent.nft_burn_event.value), UUID);

//     let block3 = chain.mineBlock([
//       Tx.contractCall(contractPrincipal(deployer_2, sampleProtocolContract), "get-loan", [types.uint(1)], deployer.address)
//     ]);
//     //The loan account in the sample protocl contact
//     const loan: any = block3.receipts[0].result.expectSome().expectTuple();
//     const dlcUuid = loan.dlc_uuid.expectSome();

//     assertEquals(hex2ascii(dlcUuid), "fakeuuid");
//     assertEquals(loan.status, '"repaid"');
//     assertEquals(loan['closing-price'], "none");
//     assertEquals(loan['vault-collateral'], "u100000000");
//     assertEquals(loan['vault-loan'], "u1000000");
//   },
// });

// Clarinet.test({
//   name: "liquidate loan on sample contract should close the loan, emit a dlclink event, and burn the nft",
//   async fn(chain: Chain, accounts: Map<string, Account>) {
//     const deployer = accounts.get('deployer')!;
//     const deployer_2 = accounts.get('deployer_2')!;

//     openLoan(chain, deployer, contractPrincipal(deployer_2, sampleProtocolContract));
//     setTrustedOracle(chain, deployer.address);

//     let liquidateCall = chain.mineBlock([
//       Tx.contractCall(contractPrincipal(deployer_2, sampleProtocolContract), "liquidate-loan", [types.uint(1), types.uint(10000)], deployer_2.address),
//     ]);
//     assertStringIncludes(liquidateCall.receipts[0].events[0].contract_event.value, 'btc-price: u10000, status: "pre-liquidated", uuid: 0x66616b6575756964');
//     assertStringIncludes(liquidateCall.receipts[0].events[1].contract_event.value, 'caller: STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.sample-contract-loan-v0-1, creator: STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.sample-contract-loan-v0-1, event-source: "dlclink:close-dlc-liquidate:v0", uuid: 0x66616b6575756964');

//     let block = chain.mineBlock([
//       Tx.contractCall(dlcManagerContract, "close-dlc-liquidate-internal", [types.buff(UUID), packageCVForLiquidation.timestamp, packageCVForLiquidation.prices, signatureForLiquidation, types.principal(contractPrincipal(deployer_2, sampleProtocolContract))], deployer.address),
//       Tx.contractCall(dlcManagerContract, "get-dlc", [types.buff(UUID)], deployer.address)
//     ]);

//     block.receipts[0].result.expectOk().expectBool(true);
//     const printEvent2 = block.receipts[0].events[0];

//     assertEquals(typeof printEvent2, 'object');
//     assertEquals(printEvent2.type, 'contract_event');
//     assertEquals(printEvent2.contract_event.topic, "print");
//     assertStringIncludes(printEvent2.contract_event.value, 'actual-closing-time: u1647332, closing-price: u1358866993200, event-source: "dlclink:close-dlc-liquidate-internal:v0", payout-ratio: (ok u80949850), uuid: 0x66616b6575756964')

//     const burnEvent = block.receipts[0].events[2];

//     assertEquals(typeof burnEvent, 'object');
//     assertEquals(burnEvent.type, 'nft_burn_event');
//     assertEquals(burnEvent.nft_burn_event.asset_identifier.split("::")[1], nftAssetContract);
//     assertEquals(burnEvent.nft_burn_event.sender.split(".")[1], dlcManagerContract);

//     const dlc: any = block.receipts[1].result.expectSome().expectTuple();
//     assertEquals(dlc['closing-price'], "(some u1358866993200)")

//     let block2 = chain.mineBlock([
//       Tx.contractCall(contractPrincipal(deployer_2, sampleProtocolContract), "get-loan", [types.uint(1)], deployer.address)
//     ]);
//     //The loan account in the sample protocl contact
//     const loan: any = block2.receipts[0].result.expectSome().expectTuple();
//     const dlcUuid = loan.dlc_uuid.expectSome();

//     assertEquals(hex2ascii(dlcUuid), "fakeuuid");
//     assertEquals(loan.status, '"liquidated"');
//     assertEquals(loan['closing-price'], "(some u1358866993200)");
//   },
// });
